% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/l_testing.R
\name{l.test}
\alias{l.test}
\title{Perform the ell-test}
\usage{
l.test(
  y,
  X,
  ind,
  lambda = -1,
  lambda_cv = -1,
  glmnet_object = NULL,
  glmnet_object_type = 1,
  adjusted = FALSE,
  smoothed = TRUE,
  return_both = FALSE
)
}
\arguments{
\item{y}{Numeric vector. Response variable.}

\item{X}{Matrix or data frame. Full column-rank \verb{n x p} design matrix; \code{nrow(X)} must match \code{length(y)}.
The intercept is included.}

\item{ind}{Integer. Index of the coefficient to test.}

\item{lambda}{Numeric. Regularization parameter for the selection LASSO.
Either a positive value or one of:
\itemize{
\item \code{-1} to choose \code{lambda.min} with \code{cv.glmnet()} called on \verb{(y, X[,-ind])},
\item \code{-2} to choose \code{lambda.1se} with \code{cv.glmnet()} called on \verb{(y, X[,-ind])}. Default \code{-1}.
}}

\item{lambda_cv}{Numeric. Regularization parameter for evaluating the ell-distribution.
Same conventions as \code{lambda}. Default is \code{-1}.}

\item{glmnet_object}{List or \code{NULL}. If a list, then either:
\itemize{
\item Length-2 list with object returned by \code{cv.glmnet()} on \verb{(y, X)} and \verb{(y, X[,-ind])} as first and second components, or
\item Length \code{d+1} list where the first component is the object returned by \code{cv.glmnet()} called on \verb{(y, X)} and the \code{i}th is when called on \verb{(y, X[,-i])}.
Default is \code{NULL}, in which case the function constructs the first type.
}}

\item{glmnet_object_type}{Integer. Either \code{1} (2-element list form) or \code{2} (\code{d+1}-element list form).
Overridden to \code{1} if \code{glmnet_object = NULL}. Default is \code{1}.}

\item{adjusted}{Logical. If \code{TRUE}, returns a p-value adjusted for post-LASSO selection of the coefficient at \code{ind}.
Default is \code{FALSE}.}

\item{smoothed}{Logical. If \code{TRUE}, smooths the unconditional p-value when the LASSO estimate at \code{ind} is zero.
Default is \code{TRUE}.}

\item{return_both}{Logical. If \code{TRUE}, returns both the unconditional and adjusted ell-test p-values.
Default is \code{FALSE}.}
}
\value{
If \code{return_both = FALSE}, a single numeric value (the ell-test p-value) is returned depending on whether \code{adjusted} is \code{TRUE} or \code{FALSE}.
If \code{return_both = TRUE}, a numeric vector of length 2: \verb{(unconditional p-value, adjusted p-value)}.
If the LASSO does not select variable \code{ind}, the adjusted p-value is \code{-1}.
}
\description{
Computes the ell-test p-value for a specified coefficient in a linear model.
}
\examples{
set.seed(1)

n <- 100
p <- 50
s <- 5
A <- 2.3

X <- matrix(rnorm(n * p), nrow = n)
X <- apply(X, 2, g)  # normalize columns; recommended

beta <- rep(0, p)
rand_ind <- sample(1:p, size = s, replace = FALSE)
j <- rand_ind[1]     # index to test
beta[rand_ind] <- (1 - 2 * rbinom(s, 1, 0.5)) * A

y <- as.numeric(X \%*\% beta + rnorm(n))

# l-test for H0: beta_j = 0
pval_l <- l.test(y, X, j)

# l-test for H0: beta_j = 2.3
pval_l <- l.test(y - 2.3 * X[, j], X, j)

# l-test for H0: beta_j = 0 with supplied lambda for CV
pval_l <- l.test(y, X, j, lambda_cv = 0.01)
pval_l_adjusted = l.test(y,X,j, adjusted = TRUE, lambda = 0.01) 
#adjusted l-test for H_j:\beta_j = 0 valid conditionally on LASSO selection using penalty 0.01, 
#and the penalty for the test statistic chosen using cross-validation
}
